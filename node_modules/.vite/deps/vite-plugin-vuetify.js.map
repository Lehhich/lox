{
  "version": 3,
  "sources": ["../../upath/build/code/upath.js", "../../@vuetify/loader-shared/dist/index.mjs", "../../vite/dist/node/index.js", "../../vite/dist/node/runtime.js", "../../vite-plugin-vuetify/dist/index.mjs"],
  "sourcesContent": ["/**\n* upath http://github.com/anodynos/upath/\n*\n* A proxy to `path`, replacing `\\` with `/` for all results (supports UNC paths) & new methods to normalize & join keeping leading `./` and add, change, default, trim file extensions.\n* Version 2.0.1 - Compiled on 2020-11-07 16:59:47\n* Repository git://github.com/anodynos/upath\n* Copyright(c) 2020 Angelos Pikoulas <agelos.pikoulas@gmail.com>\n* License MIT\n*/\n\n// Generated by uRequire v0.7.0-beta.33 target: 'lib' template: 'nodejs'\n\n\nvar VERSION = '2.0.1'; // injected by urequire-rc-inject-version\n\nvar extraFn, extraFunctions, isFunction, isString, isValidExt, name, path, propName, propValue, toUnix, upath, slice = [].slice, indexOf = [].indexOf || function (item) {\n    for (var i = 0, l = this.length; i < l; i++) {\n      if (i in this && this[i] === item)\n        return i;\n    }\n    return -1;\n  }, hasProp = {}.hasOwnProperty;\npath = require(\"path\");\nisFunction = function (val) {\n  return typeof val === \"function\";\n};\nisString = function (val) {\n  return typeof val === \"string\" || !!val && typeof val === \"object\" && Object.prototype.toString.call(val) === \"[object String]\";\n};\nupath = exports;\nupath.VERSION = typeof VERSION !== \"undefined\" && VERSION !== null ? VERSION : \"NO-VERSION\";\ntoUnix = function (p) {\n  p = p.replace(/\\\\/g, \"/\");\n  p = p.replace(/(?<!^)\\/+/g, \"/\");\n  return p;\n};\nfor (propName in path) {\n  propValue = path[propName];\n  if (isFunction(propValue)) {\n    upath[propName] = function (propName) {\n      return function () {\n        var args, result;\n        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        args = args.map(function (p) {\n          if (isString(p)) {\n            return toUnix(p);\n          } else {\n            return p;\n          }\n        });\n        result = path[propName].apply(path, args);\n        if (isString(result)) {\n          return toUnix(result);\n        } else {\n          return result;\n        }\n      };\n    }(propName);\n  } else {\n    upath[propName] = propValue;\n  }\n}\nupath.sep = \"/\";\nextraFunctions = {\n  toUnix: toUnix,\n  normalizeSafe: function (p) {\n    var result;\n    p = toUnix(p);\n    result = upath.normalize(p);\n    if (p.startsWith(\"./\") && !result.startsWith(\"./\") && !result.startsWith(\"..\")) {\n      result = \"./\" + result;\n    } else if (p.startsWith(\"//\") && !result.startsWith(\"//\")) {\n      if (p.startsWith(\"//./\")) {\n        result = \"//.\" + result;\n      } else {\n        result = \"/\" + result;\n      }\n    }\n    return result;\n  },\n  normalizeTrim: function (p) {\n    p = upath.normalizeSafe(p);\n    if (p.endsWith(\"/\")) {\n      return p.slice(0, +(p.length - 2) + 1 || 9000000000);\n    } else {\n      return p;\n    }\n  },\n  joinSafe: function () {\n    var p, p0, result;\n    p = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    result = upath.join.apply(null, p);\n    if (p.length > 0) {\n      p0 = toUnix(p[0]);\n      if (p0.startsWith(\"./\") && !result.startsWith(\"./\") && !result.startsWith(\"..\")) {\n        result = \"./\" + result;\n      } else if (p0.startsWith(\"//\") && !result.startsWith(\"//\")) {\n        if (p0.startsWith(\"//./\")) {\n          result = \"//.\" + result;\n        } else {\n          result = \"/\" + result;\n        }\n      }\n    }\n    return result;\n  },\n  addExt: function (file, ext) {\n    if (!ext) {\n      return file;\n    } else {\n      if (ext[0] !== \".\") {\n        ext = \".\" + ext;\n      }\n      return file + (file.endsWith(ext) ? \"\" : ext);\n    }\n  },\n  trimExt: function (filename, ignoreExts, maxSize) {\n    var oldExt;\n    if (maxSize == null) {\n      maxSize = 7;\n    }\n    oldExt = upath.extname(filename);\n    if (isValidExt(oldExt, ignoreExts, maxSize)) {\n      return filename.slice(0, +(filename.length - oldExt.length - 1) + 1 || 9000000000);\n    } else {\n      return filename;\n    }\n  },\n  removeExt: function (filename, ext) {\n    if (!ext) {\n      return filename;\n    } else {\n      ext = ext[0] === \".\" ? ext : \".\" + ext;\n      if (upath.extname(filename) === ext) {\n        return upath.trimExt(filename, [], ext.length);\n      } else {\n        return filename;\n      }\n    }\n  },\n  changeExt: function (filename, ext, ignoreExts, maxSize) {\n    if (maxSize == null) {\n      maxSize = 7;\n    }\n    return upath.trimExt(filename, ignoreExts, maxSize) + (!ext ? \"\" : ext[0] === \".\" ? ext : \".\" + ext);\n  },\n  defaultExt: function (filename, ext, ignoreExts, maxSize) {\n    var oldExt;\n    if (maxSize == null) {\n      maxSize = 7;\n    }\n    oldExt = upath.extname(filename);\n    if (isValidExt(oldExt, ignoreExts, maxSize)) {\n      return filename;\n    } else {\n      return upath.addExt(filename, ext);\n    }\n  }\n};\nisValidExt = function (ext, ignoreExts, maxSize) {\n  if (ignoreExts == null) {\n    ignoreExts = [];\n  }\n  return ext && ext.length <= maxSize && indexOf.call(ignoreExts.map(function (e) {\n    return (e && e[0] !== \".\" ? \".\" : \"\") + e;\n  }), ext) < 0;\n};\nfor (name in extraFunctions) {\n  if (!hasProp.call(extraFunctions, name))\n    continue;\n  extraFn = extraFunctions[name];\n  if (upath[name] !== void 0) {\n    throw new Error(\"path.\" + name + \" already exists.\");\n  } else {\n    upath[name] = extraFn;\n  }\n}\n\n;", "import { createRequire } from 'node:module';\nimport path from 'upath';\nimport { capitalize, camelize } from 'vue';\n\nfunction parseTemplate(source) {\n  const components = createSet(source.matchAll(/(?:var|const) (\\w+) = _resolveComponent\\(\"([\\w-.]+)\"\\);?/gm));\n  const directives = createSet(source.matchAll(/(?:var|const) (\\w+) = _resolveDirective\\(\"([\\w-.]+)\"\\);?/gm));\n  return { components, directives };\n}\nfunction createSet(matches) {\n  return new Set(Array.from(matches, (i) => ({\n    symbol: i[1],\n    name: capitalize(camelize(i[2])),\n    index: i.index,\n    length: i[0].length\n  })));\n}\n\nconst require$1 = createRequire(import.meta.url);\nconst importMap = require$1(\"vuetify/dist/json/importMap.json\");\nconst importMapLabs = require$1(\"vuetify/dist/json/importMap-labs.json\");\nfunction getImports(source, options) {\n  const { components, directives } = parseTemplate(source);\n  const resolvedComponents = [];\n  const resolvedDirectives = [];\n  const imports = /* @__PURE__ */ new Map();\n  const ignore = isObject(options.autoImport) && options.autoImport.ignore || null;\n  const includeLabs = isObject(options.autoImport) && options.autoImport.labs;\n  const map = includeLabs ? {\n    components: { ...importMap.components, ...importMapLabs.components },\n    directives: importMap.directives\n  } : importMap;\n  if (components.size || directives.size) {\n    components.forEach((component) => {\n      if (ignore?.includes(component.name))\n        return;\n      if (component.name in importMap.components) {\n        resolvedComponents.push(component);\n      } else if (includeLabs && component.name in importMapLabs.components) {\n        resolvedComponents.push(component);\n      }\n    });\n    directives.forEach((directive) => {\n      if (importMap.directives.includes(directive.name) && !ignore?.includes(directive.name)) {\n        resolvedDirectives.push(directive);\n      }\n    });\n  }\n  resolvedComponents.forEach((component) => {\n    addImport(imports, component.name, component.symbol, \"vuetify/lib/\" + map.components[component.name].from);\n  });\n  resolvedDirectives.forEach((directive) => {\n    addImport(imports, directive.name, directive.symbol, \"vuetify/lib/directives/index.mjs\");\n  });\n  return {\n    imports,\n    components: resolvedComponents,\n    directives: resolvedDirectives\n  };\n}\nfunction addImport(imports, name, as, from) {\n  if (!imports.has(from)) {\n    imports.set(from, []);\n  }\n  imports.get(from).push(`${name} as ${as}`);\n}\n\nfunction generateImports(source, options) {\n  const { imports, components, directives } = getImports(source, options);\n  let code = \"\";\n  if (components.length || directives.length) {\n    code += \"\\n\\n/* Vuetify */\\n\";\n    Array.from(imports).sort((a, b) => a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0).forEach(([from, names]) => {\n      code += `import { ${names.join(\", \")} } from \"${from}\"\n`;\n    });\n    code += \"\\n\";\n    source = [...components, ...directives].reduce((acc, v) => {\n      return acc.slice(0, v.index) + \" \".repeat(v.length) + acc.slice(v.index + v.length);\n    }, source);\n    if (!source.includes(\"_resolveComponent(\")) {\n      source = source.replace(\"resolveComponent as _resolveComponent, \", \"\");\n    }\n    if (!source.includes(\"_resolveDirective(\")) {\n      source = source.replace(\"resolveDirective as _resolveDirective, \", \"\");\n    }\n  }\n  return { code, source };\n}\n\nconst require = createRequire(import.meta.url);\nfunction resolveVuetifyBase() {\n  return path.dirname(require.resolve(\"vuetify/package.json\", { paths: [process.cwd()] }));\n}\nfunction isObject(value) {\n  return value !== null && typeof value === \"object\";\n}\nfunction includes(arr, val) {\n  return arr.includes(val);\n}\nfunction normalizePath(p) {\n  p = path.normalize(p);\n  return /^[a-z]:\\//i.test(p) ? \"/\" + p : p;\n}\nfunction toKebabCase(str = \"\") {\n  return str.replace(/[^a-z]/gi, \"-\").replace(/\\B([A-Z])/g, \"-$1\").toLowerCase();\n}\nconst defaultTags = {\n  video: [\"src\", \"poster\"],\n  source: [\"src\"],\n  img: [\"src\"],\n  image: [\"xlink:href\", \"href\"],\n  use: [\"xlink:href\", \"href\"]\n};\nconst transformAssetUrls = {\n  VAppBar: [\"image\"],\n  VAvatar: [\"image\"],\n  VBanner: [\"avatar\"],\n  VCard: [\"image\", \"prependAvatar\", \"appendAvatar\"],\n  VCardItem: [\"prependAvatar\", \"appendAvatar\"],\n  VCarouselItem: [\"src\", \"lazySrc\", \"srcset\"],\n  VChip: [\"prependAvatar\", \"appendAvatar\"],\n  VImg: [\"src\", \"lazySrc\", \"srcset\"],\n  VListItem: [\"prependAvatar\", \"appendAvatar\"],\n  VNavigationDrawer: [\"image\"],\n  VParallax: [\"src\", \"lazySrc\", \"srcset\"],\n  VToolbar: [\"image\"]\n};\nfor (const [tag, attrs] of Object.entries(transformAssetUrls)) {\n  attrs.forEach((attr) => {\n    if (/[A-Z]/.test(attr)) {\n      attrs.push(toKebabCase(attr));\n    }\n  });\n  transformAssetUrls[toKebabCase(tag)] = attrs;\n}\nObject.assign(transformAssetUrls, defaultTags);\n\nexport { generateImports, includes, isObject, normalizePath, resolveVuetifyBase, toKebabCase, transformAssetUrls };\n", "export { parseAst, parseAstAsync } from 'rollup/parseAst';\nimport { i as isInNodeModules, a as arraify } from './chunks/dep-Cy9twKMn.js';\nexport { b as build, g as buildErrorMessage, k as createFilter, v as createLogger, c as createServer, d as defineConfig, h as fetchModule, f as formatPostcssSourceMap, x as isFileServingAllowed, l as loadConfigFromFile, y as loadEnv, j as mergeAlias, m as mergeConfig, n as normalizePath, o as optimizeDeps, e as preprocessCSS, p as preview, r as resolveConfig, z as resolveEnvPrefix, q as rollupVersion, w as searchForWorkspaceRoot, u as send, s as sortUserPlugins, t as transformWithEsbuild } from './chunks/dep-Cy9twKMn.js';\nexport { VERSION as version } from './constants.js';\nexport { version as esbuildVersion } from 'esbuild';\nimport { existsSync, readFileSync } from 'node:fs';\nimport { ViteRuntime, ESModulesRunner } from 'vite/runtime';\nimport 'node:fs/promises';\nimport 'node:path';\nimport 'node:url';\nimport 'node:util';\nimport 'node:perf_hooks';\nimport 'node:module';\nimport 'tty';\nimport 'path';\nimport 'fs';\nimport 'node:events';\nimport 'node:stream';\nimport 'node:string_decoder';\nimport 'node:child_process';\nimport 'node:http';\nimport 'node:https';\nimport 'util';\nimport 'net';\nimport 'events';\nimport 'url';\nimport 'http';\nimport 'stream';\nimport 'os';\nimport 'child_process';\nimport 'node:os';\nimport 'node:crypto';\nimport 'node:dns';\nimport 'crypto';\nimport 'module';\nimport 'node:assert';\nimport 'node:v8';\nimport 'node:worker_threads';\nimport 'node:buffer';\nimport 'querystring';\nimport 'node:readline';\nimport 'zlib';\nimport 'buffer';\nimport 'https';\nimport 'tls';\nimport 'assert';\nimport 'node:zlib';\n\nconst CSS_LANGS_RE = (\n  // eslint-disable-next-line regexp/no-unused-capturing-group\n  /\\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\\?)/\n);\nconst isCSSRequest = (request) => CSS_LANGS_RE.test(request);\nclass SplitVendorChunkCache {\n  cache;\n  constructor() {\n    this.cache = /* @__PURE__ */ new Map();\n  }\n  reset() {\n    this.cache = /* @__PURE__ */ new Map();\n  }\n}\nfunction splitVendorChunk(options = {}) {\n  const cache = options.cache ?? new SplitVendorChunkCache();\n  return (id, { getModuleInfo }) => {\n    if (isInNodeModules(id) && !isCSSRequest(id) && staticImportedByEntry(id, getModuleInfo, cache.cache)) {\n      return \"vendor\";\n    }\n  };\n}\nfunction staticImportedByEntry(id, getModuleInfo, cache, importStack = []) {\n  if (cache.has(id)) {\n    return cache.get(id);\n  }\n  if (importStack.includes(id)) {\n    cache.set(id, false);\n    return false;\n  }\n  const mod = getModuleInfo(id);\n  if (!mod) {\n    cache.set(id, false);\n    return false;\n  }\n  if (mod.isEntry) {\n    cache.set(id, true);\n    return true;\n  }\n  const someImporterIs = mod.importers.some(\n    (importer) => staticImportedByEntry(\n      importer,\n      getModuleInfo,\n      cache,\n      importStack.concat(id)\n    )\n  );\n  cache.set(id, someImporterIs);\n  return someImporterIs;\n}\nfunction splitVendorChunkPlugin() {\n  const caches = [];\n  function createSplitVendorChunk(output, config) {\n    const cache = new SplitVendorChunkCache();\n    caches.push(cache);\n    const build = config.build ?? {};\n    const format = output?.format;\n    if (!build.ssr && !build.lib && format !== \"umd\" && format !== \"iife\") {\n      return splitVendorChunk({ cache });\n    }\n  }\n  return {\n    name: \"vite:split-vendor-chunk\",\n    config(config) {\n      let outputs = config?.build?.rollupOptions?.output;\n      if (outputs) {\n        outputs = arraify(outputs);\n        for (const output of outputs) {\n          const viteManualChunks = createSplitVendorChunk(output, config);\n          if (viteManualChunks) {\n            if (output.manualChunks) {\n              if (typeof output.manualChunks === \"function\") {\n                const userManualChunks = output.manualChunks;\n                output.manualChunks = (id, api) => {\n                  return userManualChunks(id, api) ?? viteManualChunks(id, api);\n                };\n              } else {\n                console.warn(\n                  \"(!) the `splitVendorChunk` plugin doesn't have any effect when using the object form of `build.rollupOptions.output.manualChunks`. Consider using the function form instead.\"\n                );\n              }\n            } else {\n              output.manualChunks = viteManualChunks;\n            }\n          }\n        }\n      } else {\n        return {\n          build: {\n            rollupOptions: {\n              output: {\n                manualChunks: createSplitVendorChunk({}, config)\n              }\n            }\n          }\n        };\n      }\n    },\n    buildStart() {\n      caches.forEach((cache) => cache.reset());\n    }\n  };\n}\n\nclass ServerHMRBroadcasterClient {\n  constructor(hmrChannel) {\n    this.hmrChannel = hmrChannel;\n  }\n  send(...args) {\n    let payload;\n    if (typeof args[0] === \"string\") {\n      payload = {\n        type: \"custom\",\n        event: args[0],\n        data: args[1]\n      };\n    } else {\n      payload = args[0];\n    }\n    if (payload.type !== \"custom\") {\n      throw new Error(\n        \"Cannot send non-custom events from the client to the server.\"\n      );\n    }\n    this.hmrChannel.send(payload);\n  }\n}\nclass ServerHMRConnector {\n  handlers = [];\n  hmrChannel;\n  hmrClient;\n  connected = false;\n  constructor(server) {\n    const hmrChannel = server.hot?.channels.find(\n      (c) => c.name === \"ssr\"\n    );\n    if (!hmrChannel) {\n      throw new Error(\n        \"Your version of Vite doesn't support HMR during SSR. Please, use Vite 5.1 or higher.\"\n      );\n    }\n    this.hmrClient = new ServerHMRBroadcasterClient(hmrChannel);\n    hmrChannel.api.outsideEmitter.on(\"send\", (payload) => {\n      this.handlers.forEach((listener) => listener(payload));\n    });\n    this.hmrChannel = hmrChannel;\n  }\n  isReady() {\n    return this.connected;\n  }\n  send(message) {\n    const payload = JSON.parse(message);\n    this.hmrChannel.api.innerEmitter.emit(\n      payload.event,\n      payload.data,\n      this.hmrClient\n    );\n  }\n  onUpdate(handler) {\n    this.handlers.push(handler);\n    handler({ type: \"connected\" });\n    this.connected = true;\n  }\n}\n\nfunction createHMROptions(server, options) {\n  if (server.config.server.hmr === false || options.hmr === false) {\n    return false;\n  }\n  const connection = new ServerHMRConnector(server);\n  return {\n    connection,\n    logger: options.hmr?.logger\n  };\n}\nconst prepareStackTrace = {\n  retrieveFile(id) {\n    if (existsSync(id)) {\n      return readFileSync(id, \"utf-8\");\n    }\n  }\n};\nfunction resolveSourceMapOptions(options) {\n  if (options.sourcemapInterceptor != null) {\n    if (options.sourcemapInterceptor === \"prepareStackTrace\") {\n      return prepareStackTrace;\n    }\n    if (typeof options.sourcemapInterceptor === \"object\") {\n      return { ...prepareStackTrace, ...options.sourcemapInterceptor };\n    }\n    return options.sourcemapInterceptor;\n  }\n  if (typeof process !== \"undefined\" && \"setSourceMapsEnabled\" in process) {\n    return \"node\";\n  }\n  return prepareStackTrace;\n}\nasync function createViteRuntime(server, options = {}) {\n  const hmr = createHMROptions(server, options);\n  return new ViteRuntime(\n    {\n      ...options,\n      root: server.config.root,\n      fetchModule: server.ssrFetchModule,\n      hmr,\n      sourcemapInterceptor: resolveSourceMapOptions(options)\n    },\n    options.runner || new ESModulesRunner()\n  );\n}\n\nexport { ServerHMRConnector, createViteRuntime, isCSSRequest, splitVendorChunk, splitVendorChunkPlugin };\n", "const VALID_ID_PREFIX = \"/@id/\", NULL_BYTE_PLACEHOLDER = \"__x00__\";\nlet SOURCEMAPPING_URL = \"sourceMa\";\nSOURCEMAPPING_URL += \"ppingURL\";\nconst isWindows = typeof process < \"u\" && process.platform === \"win32\";\nfunction wrapId(id) {\n  return id.startsWith(VALID_ID_PREFIX) ? id : VALID_ID_PREFIX + id.replace(\"\\0\", NULL_BYTE_PLACEHOLDER);\n}\nfunction unwrapId(id) {\n  return id.startsWith(VALID_ID_PREFIX) ? id.slice(VALID_ID_PREFIX.length).replace(NULL_BYTE_PLACEHOLDER, \"\\0\") : id;\n}\nconst windowsSlashRE = /\\\\/g;\nfunction slash(p) {\n  return p.replace(windowsSlashRE, \"/\");\n}\nconst postfixRE = /[?#].*$/;\nfunction cleanUrl(url) {\n  return url.replace(postfixRE, \"\");\n}\nfunction isPrimitive(value) {\n  return !value || typeof value != \"object\" && typeof value != \"function\";\n}\nfunction withTrailingSlash(path) {\n  return path[path.length - 1] !== \"/\" ? `${path}/` : path;\n}\nconst AsyncFunction = async function() {\n}.constructor, _DRIVE_LETTER_START_RE = /^[A-Za-z]:\\//;\nfunction normalizeWindowsPath(input = \"\") {\n  return input && input.replace(/\\\\/g, \"/\").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());\n}\nconst _IS_ABSOLUTE_RE = /^[/\\\\](?![/\\\\])|^[/\\\\]{2}(?!\\.)|^[A-Za-z]:[/\\\\]/, _DRIVE_LETTER_RE = /^[A-Za-z]:$/;\nfunction cwd() {\n  return typeof process < \"u\" && typeof process.cwd == \"function\" ? process.cwd().replace(/\\\\/g, \"/\") : \"/\";\n}\nconst resolve = function(...arguments_) {\n  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));\n  let resolvedPath = \"\", resolvedAbsolute = !1;\n  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {\n    const path = index >= 0 ? arguments_[index] : cwd();\n    !path || path.length === 0 || (resolvedPath = `${path}/${resolvedPath}`, resolvedAbsolute = isAbsolute(path));\n  }\n  return resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute), resolvedAbsolute && !isAbsolute(resolvedPath) ? `/${resolvedPath}` : resolvedPath.length > 0 ? resolvedPath : \".\";\n};\nfunction normalizeString(path, allowAboveRoot) {\n  let res = \"\", lastSegmentLength = 0, lastSlash = -1, dots = 0, char = null;\n  for (let index = 0; index <= path.length; ++index) {\n    if (index < path.length)\n      char = path[index];\n    else {\n      if (char === \"/\")\n        break;\n      char = \"/\";\n    }\n    if (char === \"/\") {\n      if (!(lastSlash === index - 1 || dots === 1)) if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== \".\" || res[res.length - 2] !== \".\") {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(\"/\");\n            lastSlashIndex === -1 ? (res = \"\", lastSegmentLength = 0) : (res = res.slice(0, lastSlashIndex), lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\")), lastSlash = index, dots = 0;\n            continue;\n          } else if (res.length > 0) {\n            res = \"\", lastSegmentLength = 0, lastSlash = index, dots = 0;\n            continue;\n          }\n        }\n        allowAboveRoot && (res += res.length > 0 ? \"/..\" : \"..\", lastSegmentLength = 2);\n      } else\n        res.length > 0 ? res += `/${path.slice(lastSlash + 1, index)}` : res = path.slice(lastSlash + 1, index), lastSegmentLength = index - lastSlash - 1;\n      lastSlash = index, dots = 0;\n    } else char === \".\" && dots !== -1 ? ++dots : dots = -1;\n  }\n  return res;\n}\nconst isAbsolute = function(p) {\n  return _IS_ABSOLUTE_RE.test(p);\n}, dirname = function(p) {\n  const segments = normalizeWindowsPath(p).replace(/\\/$/, \"\").split(\"/\").slice(0, -1);\n  return segments.length === 1 && _DRIVE_LETTER_RE.test(segments[0]) && (segments[0] += \"/\"), segments.join(\"/\") || (isAbsolute(p) ? \"/\" : \".\");\n}, decodeBase64 = typeof atob < \"u\" ? atob : (str) => Buffer.from(str, \"base64\").toString(\"utf-8\"), CHAR_FORWARD_SLASH = 47, CHAR_BACKWARD_SLASH = 92, percentRegEx = /%/g, backslashRegEx = /\\\\/g, newlineRegEx = /\\n/g, carriageReturnRegEx = /\\r/g, tabRegEx = /\\t/g, questionRegex = /\\?/g, hashRegex = /#/g;\nfunction encodePathChars(filepath) {\n  return filepath.indexOf(\"%\") !== -1 && (filepath = filepath.replace(percentRegEx, \"%25\")), !isWindows && filepath.indexOf(\"\\\\\") !== -1 && (filepath = filepath.replace(backslashRegEx, \"%5C\")), filepath.indexOf(`\n`) !== -1 && (filepath = filepath.replace(newlineRegEx, \"%0A\")), filepath.indexOf(\"\\r\") !== -1 && (filepath = filepath.replace(carriageReturnRegEx, \"%0D\")), filepath.indexOf(\"\t\") !== -1 && (filepath = filepath.replace(tabRegEx, \"%09\")), filepath;\n}\nconst posixDirname = dirname, posixResolve = resolve;\nfunction posixPathToFileHref(posixPath) {\n  let resolved = posixResolve(posixPath);\n  const filePathLast = posixPath.charCodeAt(posixPath.length - 1);\n  return (filePathLast === CHAR_FORWARD_SLASH || isWindows && filePathLast === CHAR_BACKWARD_SLASH) && resolved[resolved.length - 1] !== \"/\" && (resolved += \"/\"), resolved = encodePathChars(resolved), resolved.indexOf(\"?\") !== -1 && (resolved = resolved.replace(questionRegex, \"%3F\")), resolved.indexOf(\"#\") !== -1 && (resolved = resolved.replace(hashRegex, \"%23\")), new URL(`file://${resolved}`).href;\n}\nfunction toWindowsPath(path) {\n  return path.replace(/\\//g, \"\\\\\");\n}\nconst comma = 44, chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", intToChar = new Uint8Array(64), charToInt = new Uint8Array(128);\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c, charToInt[c] = i;\n}\nfunction decodeInteger(reader, relative) {\n  let value = 0, shift = 0, integer = 0;\n  do {\n    const c = reader.next();\n    integer = charToInt[c], value |= (integer & 31) << shift, shift += 5;\n  } while (integer & 32);\n  const shouldNegate = value & 1;\n  return value >>>= 1, shouldNegate && (value = -2147483648 | -value), relative + value;\n}\nfunction hasMoreVlq(reader, max) {\n  return reader.pos >= max ? !1 : reader.peek() !== comma;\n}\nclass StringReader {\n  constructor(buffer) {\n    this.pos = 0, this.buffer = buffer;\n  }\n  next() {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n  peek() {\n    return this.buffer.charCodeAt(this.pos);\n  }\n  indexOf(char) {\n    const { buffer, pos } = this, idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n}\nfunction decode(mappings) {\n  const { length } = mappings, reader = new StringReader(mappings), decoded = [];\n  let genColumn = 0, sourcesIndex = 0, sourceLine = 0, sourceColumn = 0, namesIndex = 0;\n  do {\n    const semi = reader.indexOf(\";\"), line = [];\n    let sorted = !0, lastCol = 0;\n    for (genColumn = 0; reader.pos < semi; ) {\n      let seg;\n      genColumn = decodeInteger(reader, genColumn), genColumn < lastCol && (sorted = !1), lastCol = genColumn, hasMoreVlq(reader, semi) ? (sourcesIndex = decodeInteger(reader, sourcesIndex), sourceLine = decodeInteger(reader, sourceLine), sourceColumn = decodeInteger(reader, sourceColumn), hasMoreVlq(reader, semi) ? (namesIndex = decodeInteger(reader, namesIndex), seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]) : seg = [genColumn, sourcesIndex, sourceLine, sourceColumn]) : seg = [genColumn], line.push(seg), reader.pos++;\n    }\n    sorted || sort(line), decoded.push(line), reader.pos = semi + 1;\n  } while (reader.pos <= length);\n  return decoded;\n}\nfunction sort(line) {\n  line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[0] - b[0];\n}\nconst COLUMN = 0, SOURCES_INDEX = 1, SOURCE_LINE = 2, SOURCE_COLUMN = 3, NAMES_INDEX = 4;\nlet found = !1;\nfunction binarySearch(haystack, needle, low, high) {\n  for (; low <= high; ) {\n    const mid = low + (high - low >> 1), cmp = haystack[mid][COLUMN] - needle;\n    if (cmp === 0)\n      return found = !0, mid;\n    cmp < 0 ? low = mid + 1 : high = mid - 1;\n  }\n  return found = !1, low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n  for (let i = index + 1; i < haystack.length && haystack[i][COLUMN] === needle; index = i++)\n    ;\n  return index;\n}\nfunction lowerBound(haystack, needle, index) {\n  for (let i = index - 1; i >= 0 && haystack[i][COLUMN] === needle; index = i--)\n    ;\n  return index;\n}\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n  const { lastKey, lastNeedle, lastIndex } = state;\n  let low = 0, high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle)\n      return found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle, lastIndex;\n    needle >= lastNeedle ? low = lastIndex === -1 ? 0 : lastIndex : high = lastIndex;\n  }\n  return state.lastKey = key, state.lastNeedle = needle, state.lastIndex = binarySearch(haystack, needle, low, high);\n}\nconst LINE_GTR_ZERO = \"`line` must be greater than 0 (lines start at line 1)\", COL_GTR_EQ_ZERO = \"`column` must be greater than or equal to 0 (columns start at column 0)\", LEAST_UPPER_BOUND = -1, GREATEST_LOWER_BOUND = 1;\nfunction cast(map) {\n  return map;\n}\nfunction decodedMappings(map) {\n  var _a;\n  return (_a = map)._decoded || (_a._decoded = decode(map._encoded));\n}\nfunction originalPositionFor(map, needle) {\n  let { line, column, bias } = needle;\n  if (line--, line < 0)\n    throw new Error(LINE_GTR_ZERO);\n  if (column < 0)\n    throw new Error(COL_GTR_EQ_ZERO);\n  const decoded = decodedMappings(map);\n  if (line >= decoded.length)\n    return OMapping(null, null, null, null);\n  const segments = decoded[line], index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n  if (index === -1)\n    return OMapping(null, null, null, null);\n  const segment = segments[index];\n  if (segment.length === 1)\n    return OMapping(null, null, null, null);\n  const { names, resolvedSources } = map;\n  return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n}\nfunction OMapping(source, line, column, name) {\n  return { source, line, column, name };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  return found ? index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index) : bias === LEAST_UPPER_BOUND && index++, index === -1 || index === segments.length ? -1 : index;\n}\nclass DecodedMap {\n  constructor(map, from) {\n    this.map = map;\n    const { mappings, names, sources } = map;\n    this.version = map.version, this.names = names || [], this._encoded = mappings || \"\", this._decodedMemo = memoizedState(), this.url = from, this.resolvedSources = (sources || []).map(\n      (s) => posixResolve(s || \"\", from)\n    );\n  }\n  _encoded;\n  _decoded;\n  _decodedMemo;\n  url;\n  version;\n  names = [];\n  resolvedSources;\n}\nfunction memoizedState() {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1\n  };\n}\nfunction getOriginalPosition(map, needle) {\n  const result = originalPositionFor(map, needle);\n  return result.column == null ? null : result;\n}\nconst VITE_RUNTIME_SOURCEMAPPING_REGEXP = new RegExp(\n  `//# ${SOURCEMAPPING_URL}=data:application/json;base64,(.+)`\n);\nclass ModuleCacheMap extends Map {\n  root;\n  constructor(root, entries) {\n    super(entries), this.root = withTrailingSlash(root);\n  }\n  normalize(fsPath) {\n    return normalizeModuleId(fsPath, this.root);\n  }\n  /**\n   * Assign partial data to the map\n   */\n  update(fsPath, mod) {\n    return fsPath = this.normalize(fsPath), super.has(fsPath) ? Object.assign(super.get(fsPath), mod) : this.setByModuleId(fsPath, mod), this;\n  }\n  setByModuleId(modulePath, mod) {\n    return super.set(modulePath, mod);\n  }\n  set(fsPath, mod) {\n    return this.setByModuleId(this.normalize(fsPath), mod);\n  }\n  getByModuleId(modulePath) {\n    super.has(modulePath) || this.setByModuleId(modulePath, {});\n    const mod = super.get(modulePath);\n    return mod.imports || Object.assign(mod, {\n      imports: /* @__PURE__ */ new Set(),\n      importers: /* @__PURE__ */ new Set()\n    }), mod;\n  }\n  get(fsPath) {\n    return this.getByModuleId(this.normalize(fsPath));\n  }\n  deleteByModuleId(modulePath) {\n    return super.delete(modulePath);\n  }\n  delete(fsPath) {\n    return this.deleteByModuleId(this.normalize(fsPath));\n  }\n  invalidate(id) {\n    const module = this.get(id);\n    module.evaluated = !1, module.meta = void 0, module.map = void 0, module.promise = void 0, module.exports = void 0, module.imports?.clear();\n  }\n  isImported({\n    importedId,\n    importedBy\n  }, seen = /* @__PURE__ */ new Set()) {\n    if (importedId = this.normalize(importedId), importedBy = this.normalize(importedBy), importedBy === importedId) return !0;\n    if (seen.has(importedId)) return !1;\n    seen.add(importedId);\n    const importers = this.getByModuleId(importedId)?.importers;\n    if (!importers) return !1;\n    if (importers.has(importedBy)) return !0;\n    for (const importer of importers)\n      if (this.isImported({\n        importedBy,\n        importedId: importer\n      }))\n        return !0;\n    return !1;\n  }\n  /**\n   * Invalidate modules that dependent on the given modules, up to the main entry\n   */\n  invalidateDepTree(ids, invalidated = /* @__PURE__ */ new Set()) {\n    for (const _id of ids) {\n      const id = this.normalize(_id);\n      if (invalidated.has(id)) continue;\n      invalidated.add(id);\n      const mod = super.get(id);\n      mod?.importers && this.invalidateDepTree(mod.importers, invalidated), super.delete(id);\n    }\n    return invalidated;\n  }\n  /**\n   * Invalidate dependency modules of the given modules, down to the bottom-level dependencies\n   */\n  invalidateSubDepTree(ids, invalidated = /* @__PURE__ */ new Set()) {\n    for (const _id of ids) {\n      const id = this.normalize(_id);\n      if (invalidated.has(id)) continue;\n      invalidated.add(id);\n      const subIds = Array.from(super.entries()).filter(([, mod]) => mod.importers?.has(id)).map(([key]) => key);\n      subIds.length && this.invalidateSubDepTree(subIds, invalidated), super.delete(id);\n    }\n    return invalidated;\n  }\n  getSourceMap(moduleId) {\n    const mod = this.get(moduleId);\n    if (mod.map) return mod.map;\n    if (!mod.meta || !(\"code\" in mod.meta)) return null;\n    const mapString = VITE_RUNTIME_SOURCEMAPPING_REGEXP.exec(mod.meta.code)?.[1];\n    if (!mapString) return null;\n    const baseFile = mod.meta.file || moduleId.split(\"?\")[0];\n    return mod.map = new DecodedMap(JSON.parse(decodeBase64(mapString)), baseFile), mod.map;\n  }\n}\nconst prefixedBuiltins = /* @__PURE__ */ new Set([\"node:test\"]);\nfunction normalizeModuleId(file, root) {\n  if (prefixedBuiltins.has(file)) return file;\n  let unixFile = slash(file).replace(/^\\/@fs\\//, isWindows ? \"\" : \"/\").replace(/^node:/, \"\").replace(/^\\/+/, \"/\");\n  return unixFile.startsWith(root) && (unixFile = unixFile.slice(root.length - 1)), unixFile.replace(/^file:\\//, \"/\");\n}\nclass HMRContext {\n  constructor(hmrClient, ownerPath) {\n    this.hmrClient = hmrClient, this.ownerPath = ownerPath, hmrClient.dataMap.has(ownerPath) || hmrClient.dataMap.set(ownerPath, {});\n    const mod = hmrClient.hotModulesMap.get(ownerPath);\n    mod && (mod.callbacks = []);\n    const staleListeners = hmrClient.ctxToListenersMap.get(ownerPath);\n    if (staleListeners)\n      for (const [event, staleFns] of staleListeners) {\n        const listeners = hmrClient.customListenersMap.get(event);\n        listeners && hmrClient.customListenersMap.set(\n          event,\n          listeners.filter((l) => !staleFns.includes(l))\n        );\n      }\n    this.newListeners = /* @__PURE__ */ new Map(), hmrClient.ctxToListenersMap.set(ownerPath, this.newListeners);\n  }\n  newListeners;\n  get data() {\n    return this.hmrClient.dataMap.get(this.ownerPath);\n  }\n  accept(deps, callback) {\n    if (typeof deps == \"function\" || !deps)\n      this.acceptDeps([this.ownerPath], ([mod]) => deps?.(mod));\n    else if (typeof deps == \"string\")\n      this.acceptDeps([deps], ([mod]) => callback?.(mod));\n    else if (Array.isArray(deps))\n      this.acceptDeps(deps, callback);\n    else\n      throw new Error(\"invalid hot.accept() usage.\");\n  }\n  // export names (first arg) are irrelevant on the client side, they're\n  // extracted in the server for propagation\n  acceptExports(_, callback) {\n    this.acceptDeps([this.ownerPath], ([mod]) => callback?.(mod));\n  }\n  dispose(cb) {\n    this.hmrClient.disposeMap.set(this.ownerPath, cb);\n  }\n  prune(cb) {\n    this.hmrClient.pruneMap.set(this.ownerPath, cb);\n  }\n  // Kept for backward compatibility (#11036)\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  decline() {\n  }\n  invalidate(message) {\n    this.hmrClient.notifyListeners(\"vite:invalidate\", {\n      path: this.ownerPath,\n      message\n    }), this.send(\"vite:invalidate\", { path: this.ownerPath, message }), this.hmrClient.logger.debug(\n      `[vite] invalidate ${this.ownerPath}${message ? `: ${message}` : \"\"}`\n    );\n  }\n  on(event, cb) {\n    const addToMap = (map) => {\n      const existing = map.get(event) || [];\n      existing.push(cb), map.set(event, existing);\n    };\n    addToMap(this.hmrClient.customListenersMap), addToMap(this.newListeners);\n  }\n  off(event, cb) {\n    const removeFromMap = (map) => {\n      const existing = map.get(event);\n      if (existing === void 0)\n        return;\n      const pruned = existing.filter((l) => l !== cb);\n      if (pruned.length === 0) {\n        map.delete(event);\n        return;\n      }\n      map.set(event, pruned);\n    };\n    removeFromMap(this.hmrClient.customListenersMap), removeFromMap(this.newListeners);\n  }\n  send(event, data) {\n    this.hmrClient.messenger.send(\n      JSON.stringify({ type: \"custom\", event, data })\n    );\n  }\n  acceptDeps(deps, callback = () => {\n  }) {\n    const mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {\n      id: this.ownerPath,\n      callbacks: []\n    };\n    mod.callbacks.push({\n      deps,\n      fn: callback\n    }), this.hmrClient.hotModulesMap.set(this.ownerPath, mod);\n  }\n}\nclass HMRMessenger {\n  constructor(connection) {\n    this.connection = connection;\n  }\n  queue = [];\n  send(message) {\n    this.queue.push(message), this.flush();\n  }\n  flush() {\n    this.connection.isReady() && (this.queue.forEach((msg) => this.connection.send(msg)), this.queue = []);\n  }\n}\nclass HMRClient {\n  constructor(logger, connection, importUpdatedModule) {\n    this.logger = logger, this.importUpdatedModule = importUpdatedModule, this.messenger = new HMRMessenger(connection);\n  }\n  hotModulesMap = /* @__PURE__ */ new Map();\n  disposeMap = /* @__PURE__ */ new Map();\n  pruneMap = /* @__PURE__ */ new Map();\n  dataMap = /* @__PURE__ */ new Map();\n  customListenersMap = /* @__PURE__ */ new Map();\n  ctxToListenersMap = /* @__PURE__ */ new Map();\n  messenger;\n  async notifyListeners(event, data) {\n    const cbs = this.customListenersMap.get(event);\n    cbs && await Promise.allSettled(cbs.map((cb) => cb(data)));\n  }\n  clear() {\n    this.hotModulesMap.clear(), this.disposeMap.clear(), this.pruneMap.clear(), this.dataMap.clear(), this.customListenersMap.clear(), this.ctxToListenersMap.clear();\n  }\n  // After an HMR update, some modules are no longer imported on the page\n  // but they may have left behind side effects that need to be cleaned up\n  // (.e.g style injections)\n  async prunePaths(paths) {\n    await Promise.all(\n      paths.map((path) => {\n        const disposer = this.disposeMap.get(path);\n        if (disposer) return disposer(this.dataMap.get(path));\n      })\n    ), paths.forEach((path) => {\n      const fn = this.pruneMap.get(path);\n      fn && fn(this.dataMap.get(path));\n    });\n  }\n  warnFailedUpdate(err, path) {\n    err.message.includes(\"fetch\") || this.logger.error(err), this.logger.error(\n      `[hmr] Failed to reload ${path}. This could be due to syntax errors or importing non-existent modules. (see errors above)`\n    );\n  }\n  updateQueue = [];\n  pendingUpdateQueue = !1;\n  /**\n   * buffer multiple hot updates triggered by the same src change\n   * so that they are invoked in the same order they were sent.\n   * (otherwise the order may be inconsistent because of the http request round trip)\n   */\n  async queueUpdate(payload) {\n    if (this.updateQueue.push(this.fetchUpdate(payload)), !this.pendingUpdateQueue) {\n      this.pendingUpdateQueue = !0, await Promise.resolve(), this.pendingUpdateQueue = !1;\n      const loading = [...this.updateQueue];\n      this.updateQueue = [], (await Promise.all(loading)).forEach((fn) => fn && fn());\n    }\n  }\n  async fetchUpdate(update) {\n    const { path, acceptedPath } = update, mod = this.hotModulesMap.get(path);\n    if (!mod)\n      return;\n    let fetchedModule;\n    const isSelfUpdate = path === acceptedPath, qualifiedCallbacks = mod.callbacks.filter(\n      ({ deps }) => deps.includes(acceptedPath)\n    );\n    if (isSelfUpdate || qualifiedCallbacks.length > 0) {\n      const disposer = this.disposeMap.get(acceptedPath);\n      disposer && await disposer(this.dataMap.get(acceptedPath));\n      try {\n        fetchedModule = await this.importUpdatedModule(update);\n      } catch (e) {\n        this.warnFailedUpdate(e, acceptedPath);\n      }\n    }\n    return () => {\n      for (const { deps, fn } of qualifiedCallbacks)\n        fn(\n          deps.map((dep) => dep === acceptedPath ? fetchedModule : void 0)\n        );\n      const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n      this.logger.debug(`[vite] hot updated: ${loggedPath}`);\n    };\n  }\n}\nfunction analyzeImportedModDifference(mod, rawId, moduleType, metadata) {\n  if (!metadata?.isDynamicImport && metadata?.importedNames?.length) {\n    const missingBindings = metadata.importedNames.filter((s) => !(s in mod));\n    if (missingBindings.length) {\n      const lastBinding = missingBindings[missingBindings.length - 1];\n      throw moduleType === \"module\" ? new SyntaxError(\n        `[vite] The requested module '${rawId}' does not provide an export named '${lastBinding}'`\n      ) : new SyntaxError(`[vite] Named export '${lastBinding}' not found. The requested module '${rawId}' is a CommonJS module, which may not support all module.exports as named exports.\nCommonJS modules can always be imported via the default export, for example using:\n\nimport pkg from '${rawId}';\nconst {${missingBindings.join(\", \")}} = pkg;\n`);\n    }\n  }\n}\nconst ssrModuleExportsKey = \"__vite_ssr_exports__\", ssrImportKey = \"__vite_ssr_import__\", ssrDynamicImportKey = \"__vite_ssr_dynamic_import__\", ssrExportAllKey = \"__vite_ssr_exportAll__\", ssrImportMetaKey = \"__vite_ssr_import_meta__\", noop = () => {\n}, silentConsole = {\n  debug: noop,\n  error: noop\n};\nfunction createHMRHandler(runtime) {\n  const queue = new Queue();\n  return (payload) => queue.enqueue(() => handleHMRPayload(runtime, payload));\n}\nasync function handleHMRPayload(runtime, payload) {\n  const hmrClient = runtime.hmrClient;\n  if (!(!hmrClient || runtime.isDestroyed()))\n    switch (payload.type) {\n      case \"connected\":\n        hmrClient.logger.debug(\"[vite] connected.\"), hmrClient.messenger.flush();\n        break;\n      case \"update\":\n        await hmrClient.notifyListeners(\"vite:beforeUpdate\", payload), await Promise.all(\n          payload.updates.map(async (update) => {\n            if (update.type === \"js-update\")\n              return update.acceptedPath = unwrapId(update.acceptedPath), update.path = unwrapId(update.path), hmrClient.queueUpdate(update);\n            hmrClient.logger.error(\n              \"[vite] css hmr is not supported in runtime mode.\"\n            );\n          })\n        ), await hmrClient.notifyListeners(\"vite:afterUpdate\", payload);\n        break;\n      case \"custom\": {\n        await hmrClient.notifyListeners(payload.event, payload.data);\n        break;\n      }\n      case \"full-reload\": {\n        const { triggeredBy } = payload, clearEntrypoints = triggeredBy ? [...runtime.entrypoints].filter(\n          (entrypoint) => runtime.moduleCache.isImported({\n            importedId: triggeredBy,\n            importedBy: entrypoint\n          })\n        ) : [...runtime.entrypoints];\n        if (!clearEntrypoints.length) break;\n        hmrClient.logger.debug(\"[vite] program reload\"), await hmrClient.notifyListeners(\"vite:beforeFullReload\", payload), runtime.moduleCache.clear();\n        for (const id of clearEntrypoints)\n          await runtime.executeUrl(id);\n        break;\n      }\n      case \"prune\":\n        await hmrClient.notifyListeners(\"vite:beforePrune\", payload), await hmrClient.prunePaths(payload.paths);\n        break;\n      case \"error\": {\n        await hmrClient.notifyListeners(\"vite:error\", payload);\n        const err = payload.err;\n        hmrClient.logger.error(\n          `[vite] Internal Server Error\n${err.message}\n${err.stack}`\n        );\n        break;\n      }\n      default:\n        return payload;\n    }\n}\nclass Queue {\n  queue = [];\n  pending = !1;\n  enqueue(promise) {\n    return new Promise((resolve2, reject) => {\n      this.queue.push({\n        promise,\n        resolve: resolve2,\n        reject\n      }), this.dequeue();\n    });\n  }\n  dequeue() {\n    if (this.pending)\n      return !1;\n    const item = this.queue.shift();\n    return item ? (this.pending = !0, item.promise().then(item.resolve).catch(item.reject).finally(() => {\n      this.pending = !1, this.dequeue();\n    }), !0) : !1;\n  }\n}\nconst sourceMapCache = {}, fileContentsCache = {}, moduleGraphs = /* @__PURE__ */ new Set(), retrieveFileHandlers = /* @__PURE__ */ new Set(), retrieveSourceMapHandlers = /* @__PURE__ */ new Set(), createExecHandlers = (handlers) => (...args) => {\n  for (const handler of handlers) {\n    const result = handler(...args);\n    if (result) return result;\n  }\n  return null;\n}, retrieveFileFromHandlers = createExecHandlers(retrieveFileHandlers), retrieveSourceMapFromHandlers = createExecHandlers(\n  retrieveSourceMapHandlers\n);\nlet overridden = !1;\nconst originalPrepare = Error.prepareStackTrace;\nfunction resetInterceptor(runtime, options) {\n  moduleGraphs.delete(runtime.moduleCache), options.retrieveFile && retrieveFileHandlers.delete(options.retrieveFile), options.retrieveSourceMap && retrieveSourceMapHandlers.delete(options.retrieveSourceMap), moduleGraphs.size === 0 && (Error.prepareStackTrace = originalPrepare, overridden = !1);\n}\nfunction interceptStackTrace(runtime, options = {}) {\n  return overridden || (Error.prepareStackTrace = prepareStackTrace, overridden = !0), moduleGraphs.add(runtime.moduleCache), options.retrieveFile && retrieveFileHandlers.add(options.retrieveFile), options.retrieveSourceMap && retrieveSourceMapHandlers.add(options.retrieveSourceMap), () => resetInterceptor(runtime, options);\n}\nfunction supportRelativeURL(file, url) {\n  if (!file) return url;\n  const dir = posixDirname(slash(file)), match = /^\\w+:\\/\\/[^/]*/.exec(dir);\n  let protocol = match ? match[0] : \"\";\n  const startPath = dir.slice(protocol.length);\n  return protocol && /^\\/\\w:/.test(startPath) ? (protocol += \"/\", protocol + slash(posixResolve(startPath, url))) : protocol + posixResolve(startPath, url);\n}\nfunction getRuntimeSourceMap(position) {\n  for (const moduleCache of moduleGraphs) {\n    const sourceMap = moduleCache.getSourceMap(position.source);\n    if (sourceMap)\n      return {\n        url: position.source,\n        map: sourceMap,\n        vite: !0\n      };\n  }\n  return null;\n}\nfunction retrieveFile(path) {\n  if (path in fileContentsCache) return fileContentsCache[path];\n  const content = retrieveFileFromHandlers(path);\n  return typeof content == \"string\" ? (fileContentsCache[path] = content, content) : null;\n}\nfunction retrieveSourceMapURL(source) {\n  const fileData = retrieveFile(source);\n  if (!fileData) return null;\n  const re = /\\/\\/[@#]\\s*sourceMappingURL=([^\\s'\"]+)\\s*$|\\/\\*[@#]\\s*sourceMappingURL=[^\\s*'\"]+\\s*\\*\\/\\s*$/gm;\n  let lastMatch, match;\n  for (; match = re.exec(fileData); ) lastMatch = match;\n  return lastMatch ? lastMatch[1] : null;\n}\nconst reSourceMap = /^data:application\\/json[^,]+base64,/;\nfunction retrieveSourceMap(source) {\n  const urlAndMap = retrieveSourceMapFromHandlers(source);\n  if (urlAndMap) return urlAndMap;\n  let sourceMappingURL = retrieveSourceMapURL(source);\n  if (!sourceMappingURL) return null;\n  let sourceMapData;\n  if (reSourceMap.test(sourceMappingURL)) {\n    const rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(\",\") + 1);\n    sourceMapData = Buffer.from(rawData, \"base64\").toString(), sourceMappingURL = source;\n  } else\n    sourceMappingURL = supportRelativeURL(source, sourceMappingURL), sourceMapData = retrieveFile(sourceMappingURL);\n  return sourceMapData ? {\n    url: sourceMappingURL,\n    map: sourceMapData\n  } : null;\n}\nfunction mapSourcePosition(position) {\n  if (!position.source) return position;\n  let sourceMap = getRuntimeSourceMap(position);\n  if (sourceMap || (sourceMap = sourceMapCache[position.source]), !sourceMap) {\n    const urlAndMap = retrieveSourceMap(position.source);\n    if (urlAndMap && urlAndMap.map) {\n      const url = urlAndMap.url;\n      sourceMap = sourceMapCache[position.source] = {\n        url,\n        map: new DecodedMap(\n          typeof urlAndMap.map == \"string\" ? JSON.parse(urlAndMap.map) : urlAndMap.map,\n          url\n        )\n      };\n      const contents = sourceMap.map?.map.sourcesContent;\n      sourceMap.map && contents && sourceMap.map.resolvedSources.forEach((source, i) => {\n        const content = contents[i];\n        if (content && source && url) {\n          const contentUrl = supportRelativeURL(url, source);\n          fileContentsCache[contentUrl] = content;\n        }\n      });\n    } else\n      sourceMap = sourceMapCache[position.source] = {\n        url: null,\n        map: null\n      };\n  }\n  if (sourceMap && sourceMap.map && sourceMap.url) {\n    const originalPosition = getOriginalPosition(sourceMap.map, position);\n    if (originalPosition && originalPosition.source != null)\n      return originalPosition.source = supportRelativeURL(\n        sourceMap.url,\n        originalPosition.source\n      ), sourceMap.vite && (originalPosition._vite = !0), originalPosition;\n  }\n  return position;\n}\nfunction mapEvalOrigin(origin) {\n  let match = /^eval at ([^(]+) \\((.+):(\\d+):(\\d+)\\)$/.exec(origin);\n  if (match) {\n    const position = mapSourcePosition({\n      name: null,\n      source: match[2],\n      line: +match[3],\n      column: +match[4] - 1\n    });\n    return `eval at ${match[1]} (${position.source}:${position.line}:${position.column + 1})`;\n  }\n  return match = /^eval at ([^(]+) \\((.+)\\)$/.exec(origin), match ? `eval at ${match[1]} (${mapEvalOrigin(match[2])})` : origin;\n}\nfunction CallSiteToString() {\n  let fileName, fileLocation = \"\";\n  if (this.isNative())\n    fileLocation = \"native\";\n  else {\n    fileName = this.getScriptNameOrSourceURL(), !fileName && this.isEval() && (fileLocation = this.getEvalOrigin(), fileLocation += \", \"), fileName ? fileLocation += fileName : fileLocation += \"<anonymous>\";\n    const lineNumber = this.getLineNumber();\n    if (lineNumber != null) {\n      fileLocation += `:${lineNumber}`;\n      const columnNumber = this.getColumnNumber();\n      columnNumber && (fileLocation += `:${columnNumber}`);\n    }\n  }\n  let line = \"\";\n  const functionName = this.getFunctionName();\n  let addSuffix = !0;\n  const isConstructor = this.isConstructor();\n  if (this.isToplevel() || isConstructor)\n    isConstructor ? line += `new ${functionName || \"<anonymous>\"}` : functionName ? line += functionName : (line += fileLocation, addSuffix = !1);\n  else {\n    let typeName = this.getTypeName();\n    typeName === \"[object Object]\" && (typeName = \"null\");\n    const methodName = this.getMethodName();\n    functionName ? (typeName && functionName.indexOf(typeName) !== 0 && (line += `${typeName}.`), line += functionName, methodName && functionName.indexOf(`.${methodName}`) !== functionName.length - methodName.length - 1 && (line += ` [as ${methodName}]`)) : line += `${typeName}.${methodName || \"<anonymous>\"}`;\n  }\n  return addSuffix && (line += ` (${fileLocation})`), line;\n}\nfunction cloneCallSite(frame) {\n  const object = {};\n  return Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach((name) => {\n    const key = name;\n    object[key] = /^(?:is|get)/.test(name) ? function() {\n      return frame[key].call(frame);\n    } : frame[key];\n  }), object.toString = CallSiteToString, object;\n}\nfunction wrapCallSite(frame, state) {\n  if (state === void 0 && (state = { nextPosition: null, curPosition: null }), frame.isNative())\n    return state.curPosition = null, frame;\n  const source = frame.getFileName() || frame.getScriptNameOrSourceURL();\n  if (source) {\n    const line = frame.getLineNumber();\n    let column = frame.getColumnNumber() - 1;\n    const headerLength = 62;\n    line === 1 && column > headerLength && !frame.isEval() && (column -= headerLength);\n    const position = mapSourcePosition({\n      name: null,\n      source,\n      line,\n      column\n    });\n    state.curPosition = position, frame = cloneCallSite(frame);\n    const originalFunctionName = frame.getFunctionName;\n    return frame.getFunctionName = function() {\n      const name = state.nextPosition == null ? originalFunctionName() : state.nextPosition.name || originalFunctionName();\n      return name === \"eval\" && \"_vite\" in position ? null : name;\n    }, frame.getFileName = function() {\n      return position.source ?? void 0;\n    }, frame.getLineNumber = function() {\n      return position.line;\n    }, frame.getColumnNumber = function() {\n      return position.column + 1;\n    }, frame.getScriptNameOrSourceURL = function() {\n      return position.source;\n    }, frame;\n  }\n  let origin = frame.isEval() && frame.getEvalOrigin();\n  return origin && (origin = mapEvalOrigin(origin), frame = cloneCallSite(frame), frame.getEvalOrigin = function() {\n    return origin || void 0;\n  }), frame;\n}\nfunction prepareStackTrace(error, stack) {\n  const name = error.name || \"Error\", message = error.message || \"\", errorString = `${name}: ${message}`, state = { nextPosition: null, curPosition: null }, processedStack = [];\n  for (let i = stack.length - 1; i >= 0; i--)\n    processedStack.push(`\n    at ${wrapCallSite(stack[i], state)}`), state.nextPosition = state.curPosition;\n  return state.curPosition = state.nextPosition = null, errorString + processedStack.reverse().join(\"\");\n}\nfunction enableSourceMapSupport(runtime) {\n  if (runtime.options.sourcemapInterceptor === \"node\") {\n    if (typeof process > \"u\")\n      throw new TypeError(\n        `Cannot use \"sourcemapInterceptor: 'node'\" because global \"process\" variable is not available.`\n      );\n    if (typeof process.setSourceMapsEnabled != \"function\")\n      throw new TypeError(\n        `Cannot use \"sourcemapInterceptor: 'node'\" because \"process.setSourceMapsEnabled\" function is not available. Please use Node >= 16.6.0.`\n      );\n    const isEnabledAlready = process.sourceMapsEnabled ?? !1;\n    return process.setSourceMapsEnabled(!0), () => !isEnabledAlready && process.setSourceMapsEnabled(!1);\n  }\n  return interceptStackTrace(\n    runtime,\n    typeof runtime.options.sourcemapInterceptor == \"object\" ? runtime.options.sourcemapInterceptor : void 0\n  );\n}\nclass ViteRuntime {\n  constructor(options, runner, debug) {\n    this.options = options, this.runner = runner, this.debug = debug, this.moduleCache = options.moduleCache ?? new ModuleCacheMap(options.root), typeof options.hmr == \"object\" && (this.hmrClient = new HMRClient(\n      options.hmr.logger === !1 ? silentConsole : options.hmr.logger || console,\n      options.hmr.connection,\n      ({ acceptedPath, ssrInvalidates }) => (this.moduleCache.invalidate(acceptedPath), ssrInvalidates && this.invalidateFiles(ssrInvalidates), this.executeUrl(acceptedPath))\n    ), options.hmr.connection.onUpdate(createHMRHandler(this))), options.sourcemapInterceptor !== !1 && (this._resetSourceMapSupport = enableSourceMapSupport(this));\n  }\n  /**\n   * Holds the cache of modules\n   * Keys of the map are ids\n   */\n  moduleCache;\n  hmrClient;\n  entrypoints = /* @__PURE__ */ new Set();\n  idToUrlMap = /* @__PURE__ */ new Map();\n  fileToIdMap = /* @__PURE__ */ new Map();\n  envProxy = new Proxy({}, {\n    get(_, p) {\n      throw new Error(\n        `[vite-runtime] Dynamic access of \"import.meta.env\" is not supported. Please, use \"import.meta.env.${String(p)}\" instead.`\n      );\n    }\n  });\n  _destroyed = !1;\n  _resetSourceMapSupport;\n  /**\n   * URL to execute. Accepts file path, server path or id relative to the root.\n   */\n  async executeUrl(url) {\n    url = this.normalizeEntryUrl(url);\n    const fetchedModule = await this.cachedModule(url);\n    return await this.cachedRequest(url, fetchedModule);\n  }\n  /**\n   * Entrypoint URL to execute. Accepts file path, server path or id relative to the root.\n   * In the case of a full reload triggered by HMR, this is the module that will be reloaded.\n   * If this method is called multiple times, all entrypoints will be reloaded one at a time.\n   */\n  async executeEntrypoint(url) {\n    url = this.normalizeEntryUrl(url);\n    const fetchedModule = await this.cachedModule(url);\n    return await this.cachedRequest(url, fetchedModule, [], {\n      entrypoint: !0\n    });\n  }\n  /**\n   * Clear all caches including HMR listeners.\n   */\n  clearCache() {\n    this.moduleCache.clear(), this.idToUrlMap.clear(), this.entrypoints.clear(), this.hmrClient?.clear();\n  }\n  /**\n   * Clears all caches, removes all HMR listeners, and resets source map support.\n   * This method doesn't stop the HMR connection.\n   */\n  async destroy() {\n    this._resetSourceMapSupport?.(), this.clearCache(), this.hmrClient = void 0, this._destroyed = !0;\n  }\n  /**\n   * Returns `true` if the runtime has been destroyed by calling `destroy()` method.\n   */\n  isDestroyed() {\n    return this._destroyed;\n  }\n  invalidateFiles(files) {\n    files.forEach((file) => {\n      const ids = this.fileToIdMap.get(file);\n      ids && ids.forEach((id) => this.moduleCache.invalidate(id));\n    });\n  }\n  // we don't use moduleCache.normalize because this URL doesn't have to follow the same rules\n  // this URL is something that user passes down manually, and is later resolved by fetchModule\n  // moduleCache.normalize is used on resolved \"file\" property\n  normalizeEntryUrl(url) {\n    if (url[0] === \".\")\n      return url;\n    url.startsWith(\"file://\") && (url = url.slice(isWindows ? 8 : 7)), url = slash(url);\n    const _root = this.options.root, root = _root[_root.length - 1] === \"/\" ? _root : `${_root}/`;\n    return url.startsWith(root) ? url.slice(root.length - 1) : url[0] === \"/\" ? url : wrapId(url);\n  }\n  processImport(exports, fetchResult, metadata) {\n    if (!(\"externalize\" in fetchResult))\n      return exports;\n    const { id, type } = fetchResult;\n    return type !== \"module\" && type !== \"commonjs\" || analyzeImportedModDifference(exports, id, type, metadata), exports;\n  }\n  async cachedRequest(id, fetchedModule, callstack = [], metadata) {\n    const moduleId = fetchedModule.id;\n    metadata?.entrypoint && this.entrypoints.add(moduleId);\n    const mod = this.moduleCache.getByModuleId(moduleId), { imports, importers } = mod, importee = callstack[callstack.length - 1];\n    if (importee && importers.add(importee), (callstack.includes(moduleId) || Array.from(imports.values()).some((i) => importers.has(i))) && mod.exports)\n      return this.processImport(mod.exports, fetchedModule, metadata);\n    let debugTimer;\n    this.debug && (debugTimer = setTimeout(() => {\n      const getStack = () => `stack:\n${[...callstack, moduleId].reverse().map((p) => `  - ${p}`).join(`\n`)}`;\n      this.debug(\n        `[vite-runtime] module ${moduleId} takes over 2s to load.\n${getStack()}`\n      );\n    }, 2e3));\n    try {\n      if (mod.promise)\n        return this.processImport(await mod.promise, fetchedModule, metadata);\n      const promise = this.directRequest(id, fetchedModule, callstack);\n      return mod.promise = promise, mod.evaluated = !1, this.processImport(await promise, fetchedModule, metadata);\n    } finally {\n      mod.evaluated = !0, debugTimer && clearTimeout(debugTimer);\n    }\n  }\n  async cachedModule(id, importer) {\n    if (this._destroyed)\n      throw new Error(\"[vite] Vite runtime has been destroyed.\");\n    const normalized = this.idToUrlMap.get(id);\n    if (normalized) {\n      const mod2 = this.moduleCache.getByModuleId(normalized);\n      if (mod2.meta)\n        return mod2.meta;\n    }\n    this.debug?.(\"[vite-runtime] fetching\", id);\n    const fetchedModule = id.startsWith(\"data:\") ? { externalize: id, type: \"builtin\" } : await this.options.fetchModule(id, importer), idQuery = id.split(\"?\")[1], query = idQuery ? `?${idQuery}` : \"\", file = \"file\" in fetchedModule ? fetchedModule.file : void 0, fullFile = file ? `${file}${query}` : id, moduleId = this.moduleCache.normalize(fullFile), mod = this.moduleCache.getByModuleId(moduleId);\n    if (fetchedModule.id = moduleId, mod.meta = fetchedModule, file) {\n      const fileModules = this.fileToIdMap.get(file) || [];\n      fileModules.push(moduleId), this.fileToIdMap.set(file, fileModules);\n    }\n    return this.idToUrlMap.set(id, moduleId), this.idToUrlMap.set(unwrapId(id), moduleId), fetchedModule;\n  }\n  // override is allowed, consider this a public API\n  async directRequest(id, fetchResult, _callstack) {\n    const moduleId = fetchResult.id, callstack = [..._callstack, moduleId], mod = this.moduleCache.getByModuleId(moduleId), request = async (dep, metadata) => {\n      const fetchedModule = await this.cachedModule(dep, moduleId);\n      return this.moduleCache.getByModuleId(fetchedModule.id).importers.add(moduleId), mod.imports.add(fetchedModule.id), this.cachedRequest(dep, fetchedModule, callstack, metadata);\n    }, dynamicRequest = async (dep) => (dep = String(dep), dep[0] === \".\" && (dep = posixResolve(posixDirname(id), dep)), request(dep, { isDynamicImport: !0 }));\n    if (\"externalize\" in fetchResult) {\n      const { externalize } = fetchResult;\n      this.debug?.(\"[vite-runtime] externalizing\", externalize);\n      const exports2 = await this.runner.runExternalModule(externalize);\n      return mod.exports = exports2, exports2;\n    }\n    const { code, file } = fetchResult;\n    if (code == null) {\n      const importer = callstack[callstack.length - 2];\n      throw new Error(\n        `[vite-runtime] Failed to load \"${id}\"${importer ? ` imported from ${importer}` : \"\"}`\n      );\n    }\n    const modulePath = cleanUrl(file || moduleId), href = posixPathToFileHref(modulePath), filename = modulePath, dirname2 = posixDirname(modulePath), meta = {\n      filename: isWindows ? toWindowsPath(filename) : filename,\n      dirname: isWindows ? toWindowsPath(dirname2) : dirname2,\n      url: href,\n      env: this.envProxy,\n      resolve(id2, parent) {\n        throw new Error(\n          '[vite-runtime] \"import.meta.resolve\" is not supported.'\n        );\n      },\n      // should be replaced during transformation\n      glob() {\n        throw new Error('[vite-runtime] \"import.meta.glob\" is not supported.');\n      }\n    }, exports = /* @__PURE__ */ Object.create(null);\n    Object.defineProperty(exports, Symbol.toStringTag, {\n      value: \"Module\",\n      enumerable: !1,\n      configurable: !1\n    }), mod.exports = exports;\n    let hotContext;\n    this.hmrClient && Object.defineProperty(meta, \"hot\", {\n      enumerable: !0,\n      get: () => {\n        if (!this.hmrClient)\n          throw new Error(\"[vite-runtime] HMR client was destroyed.\");\n        return this.debug?.(\"[vite-runtime] creating hmr context for\", moduleId), hotContext ||= new HMRContext(this.hmrClient, moduleId), hotContext;\n      },\n      set: (value) => {\n        hotContext = value;\n      }\n    });\n    const context = {\n      [ssrImportKey]: request,\n      [ssrDynamicImportKey]: dynamicRequest,\n      [ssrModuleExportsKey]: exports,\n      [ssrExportAllKey]: (obj) => exportAll(exports, obj),\n      [ssrImportMetaKey]: meta\n    };\n    return this.debug?.(\"[vite-runtime] executing\", href), await this.runner.runViteModule(context, code, id), exports;\n  }\n}\nfunction exportAll(exports, sourceModule) {\n  if (exports !== sourceModule && !(isPrimitive(sourceModule) || Array.isArray(sourceModule) || sourceModule instanceof Promise)) {\n    for (const key in sourceModule)\n      if (key !== \"default\" && key !== \"__esModule\")\n        try {\n          Object.defineProperty(exports, key, {\n            enumerable: !0,\n            configurable: !0,\n            get: () => sourceModule[key]\n          });\n        } catch {\n        }\n  }\n}\nclass ESModulesRunner {\n  async runViteModule(context, code) {\n    await new AsyncFunction(\n      ssrModuleExportsKey,\n      ssrImportMetaKey,\n      ssrImportKey,\n      ssrDynamicImportKey,\n      ssrExportAllKey,\n      // source map should already be inlined by Vite\n      '\"use strict\";' + code\n    )(\n      context[ssrModuleExportsKey],\n      context[ssrImportMetaKey],\n      context[ssrImportKey],\n      context[ssrDynamicImportKey],\n      context[ssrExportAllKey]\n    ), Object.seal(context[ssrModuleExportsKey]);\n  }\n  runExternalModule(filepath) {\n    return import(filepath);\n  }\n}\nexport {\n  ESModulesRunner,\n  ModuleCacheMap,\n  ViteRuntime,\n  ssrDynamicImportKey,\n  ssrExportAllKey,\n  ssrImportKey,\n  ssrImportMetaKey,\n  ssrModuleExportsKey\n};\n", "import { generateImports, resolveVuetifyBase, isObject, normalizePath, includes, transformAssetUrls } from '@vuetify/loader-shared';\nexport { transformAssetUrls } from '@vuetify/loader-shared';\nimport { createFilter } from 'vite';\nimport { URLSearchParams } from 'url';\nimport path from 'upath';\n\nfunction parseId(id) {\n  const [pathname, query] = id.split(\"?\");\n  return {\n    query: query ? Object.fromEntries(new URLSearchParams(query)) : null,\n    path: pathname ?? id\n  };\n}\nfunction importPlugin(options) {\n  let filter;\n  return {\n    name: \"vuetify:import\",\n    configResolved(config) {\n      const vuetifyIdx = config.plugins.findIndex((plugin) => plugin.name === \"vuetify:import\");\n      const vueIdx = config.plugins.findIndex((plugin) => plugin.name === \"vite:vue\");\n      if (vuetifyIdx < vueIdx) {\n        throw new Error(\"Vuetify plugin must be loaded after the vue plugin\");\n      }\n      const vueOptions = config.plugins[vueIdx].api.options;\n      filter = createFilter(vueOptions.include, vueOptions.exclude);\n    },\n    async transform(code, id) {\n      const { query, path } = parseId(id);\n      const isVueVirtual = query && \"vue\" in query;\n      const isVueFile = !isVueVirtual && filter(path) && !/^import { render as _sfc_render } from \".*\"$/m.test(code);\n      const isVueTemplate = isVueVirtual && (query.type === \"template\" || query.type === \"script\" && query.setup === \"true\");\n      if (isVueFile || isVueTemplate) {\n        const { code: imports, source } = generateImports(code, options);\n        return {\n          code: source + imports,\n          map: null\n        };\n      }\n      return null;\n    }\n  };\n}\n\nfunction isSubdir(root, test) {\n  const relative = path.relative(root, test);\n  return relative && !relative.startsWith(\"..\") && !path.isAbsolute(relative);\n}\nconst PLUGIN_VIRTUAL_PREFIX = \"virtual:\";\nconst PLUGIN_VIRTUAL_NAME = \"plugin-vuetify\";\nconst VIRTUAL_MODULE_ID = `${PLUGIN_VIRTUAL_PREFIX}${PLUGIN_VIRTUAL_NAME}`;\nfunction stylesPlugin(options) {\n  const vuetifyBase = resolveVuetifyBase();\n  let configFile;\n  const tempFiles = /* @__PURE__ */ new Map();\n  return {\n    name: \"vuetify:styles\",\n    enforce: \"pre\",\n    configResolved(config) {\n      if (isObject(options.styles)) {\n        if (path.isAbsolute(options.styles.configFile)) {\n          configFile = options.styles.configFile;\n        } else {\n          configFile = path.join(config.root || process.cwd(), options.styles.configFile);\n        }\n      }\n    },\n    async resolveId(source, importer, { custom }) {\n      if (source === \"vuetify/styles\" || importer && source.endsWith(\".css\") && isSubdir(vuetifyBase, path.isAbsolute(source) ? source : importer)) {\n        if (options.styles === \"none\") {\n          return `${PLUGIN_VIRTUAL_PREFIX}__void__`;\n        } else if (options.styles === \"sass\") {\n          const target = source.replace(/\\.css$/, \".sass\");\n          return this.resolve(target, importer, { skipSelf: true, custom });\n        } else if (isObject(options.styles)) {\n          const resolution = await this.resolve(source, importer, { skipSelf: true, custom });\n          if (!resolution)\n            return null;\n          const target = resolution.id.replace(/\\.css$/, \".sass\");\n          const file = path.relative(path.join(vuetifyBase, \"lib\"), target);\n          const contents = `@use \"${normalizePath(configFile)}\"\n@use \"${normalizePath(target)}\"`;\n          tempFiles.set(file, contents);\n          return `${VIRTUAL_MODULE_ID}:${file}`;\n        }\n      } else if (source.startsWith(`/${PLUGIN_VIRTUAL_NAME}:`)) {\n        return PLUGIN_VIRTUAL_PREFIX + source.slice(1);\n      } else if (source.startsWith(`/@id/__x00__${PLUGIN_VIRTUAL_NAME}:`)) {\n        return PLUGIN_VIRTUAL_PREFIX + source.slice(12);\n      } else if (source.startsWith(`/${VIRTUAL_MODULE_ID}:`)) {\n        return source.slice(1);\n      }\n      return null;\n    },\n    load(id) {\n      if (new RegExp(`^${PLUGIN_VIRTUAL_PREFIX}__void__(\\\\?.*)?$`).test(id)) {\n        return \"\";\n      }\n      if (id.startsWith(`${VIRTUAL_MODULE_ID}`)) {\n        const file = new RegExp(`^${VIRTUAL_MODULE_ID}:(.*?)(\\\\?.*)?$`).exec(id)[1];\n        return tempFiles.get(file);\n      }\n      return null;\n    }\n  };\n}\n\nfunction vuetify(_options = {}) {\n  const options = {\n    autoImport: true,\n    styles: true,\n    ..._options\n  };\n  const plugins = [];\n  if (options.autoImport) {\n    plugins.push(importPlugin(options));\n  }\n  if (includes([\"none\", \"sass\"], options.styles) || isObject(options.styles)) {\n    plugins.push(stylesPlugin(options));\n  }\n  return plugins;\n}\nvuetify.transformAssetUrls = transformAssetUrls;\n\nexport { vuetify as default };\n"],
  "mappings": "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",
  "names": ["VERSION", "path", "propName", "require", "path", "import_node_module", "import_url", "import_upath", "path"]
}
