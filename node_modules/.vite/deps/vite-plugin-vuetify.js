import {
  createFilter,
  require_assert,
  require_buffer,
  require_child_process,
  require_crypto,
  require_http,
  require_https,
  require_main,
  require_module,
  require_net,
  require_node_assert,
  require_node_buffer,
  require_node_child_process,
  require_node_crypto,
  require_node_dns,
  require_node_events,
  require_node_readline,
  require_node_stream,
  require_node_string_decoder,
  require_node_util,
  require_node_v8,
  require_node_worker_threads,
  require_node_zlib,
  require_querystring,
  require_tls,
  require_zlib
} from "./chunk-ABLY2XUC.js";
import {
  require_events,
  require_node_os,
  require_os,
  require_stream,
  require_util
} from "./chunk-4IF5DJ7Y.js";
import {
  require_node_fs,
  require_node_perf_hooks,
  require_promises,
  require_tty
} from "./chunk-FVKISGTQ.js";
import {
  require_node_http
} from "./chunk-IMCWEQVX.js";
import {
  require_node_https
} from "./chunk-ELUVRKFY.js";
import {
  require_node_module,
  require_node_url
} from "./chunk-4S5KUDX2.js";
import {
  require_node_path
} from "./chunk-4L7PAIBO.js";
import {
  require_url
} from "./chunk-6MZOJPQH.js";
import {
  require_fs
} from "./chunk-QEB7QRGG.js";
import {
  require_path
} from "./chunk-EQTMJ7GU.js";
import "./chunk-PUSYUVIY.js";
import {
  camelize,
  capitalize
} from "./chunk-AM7VHYIE.js";
import {
  __commonJS,
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/upath/build/code/upath.js
var require_upath = __commonJS({
  "node_modules/upath/build/code/upath.js"(exports) {
    var VERSION2 = "2.0.1";
    var extraFn;
    var extraFunctions;
    var isFunction;
    var isString;
    var isValidExt;
    var name;
    var path3;
    var propName;
    var propValue;
    var toUnix;
    var upath;
    var slice = [].slice;
    var indexOf = [].indexOf || function(item) {
      for (var i = 0, l = this.length; i < l; i++) {
        if (i in this && this[i] === item)
          return i;
      }
      return -1;
    };
    var hasProp = {}.hasOwnProperty;
    path3 = require_path();
    isFunction = function(val) {
      return typeof val === "function";
    };
    isString = function(val) {
      return typeof val === "string" || !!val && typeof val === "object" && Object.prototype.toString.call(val) === "[object String]";
    };
    upath = exports;
    upath.VERSION = typeof VERSION2 !== "undefined" && VERSION2 !== null ? VERSION2 : "NO-VERSION";
    toUnix = function(p) {
      p = p.replace(/\\/g, "/");
      p = p.replace(new RegExp("(?<!^)\\/+", "g"), "/");
      return p;
    };
    for (propName in path3) {
      propValue = path3[propName];
      if (isFunction(propValue)) {
        upath[propName] = /* @__PURE__ */ function(propName2) {
          return function() {
            var args, result;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            args = args.map(function(p) {
              if (isString(p)) {
                return toUnix(p);
              } else {
                return p;
              }
            });
            result = path3[propName2].apply(path3, args);
            if (isString(result)) {
              return toUnix(result);
            } else {
              return result;
            }
          };
        }(propName);
      } else {
        upath[propName] = propValue;
      }
    }
    upath.sep = "/";
    extraFunctions = {
      toUnix,
      normalizeSafe: function(p) {
        var result;
        p = toUnix(p);
        result = upath.normalize(p);
        if (p.startsWith("./") && !result.startsWith("./") && !result.startsWith("..")) {
          result = "./" + result;
        } else if (p.startsWith("//") && !result.startsWith("//")) {
          if (p.startsWith("//./")) {
            result = "//." + result;
          } else {
            result = "/" + result;
          }
        }
        return result;
      },
      normalizeTrim: function(p) {
        p = upath.normalizeSafe(p);
        if (p.endsWith("/")) {
          return p.slice(0, +(p.length - 2) + 1 || 9e9);
        } else {
          return p;
        }
      },
      joinSafe: function() {
        var p, p0, result;
        p = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        result = upath.join.apply(null, p);
        if (p.length > 0) {
          p0 = toUnix(p[0]);
          if (p0.startsWith("./") && !result.startsWith("./") && !result.startsWith("..")) {
            result = "./" + result;
          } else if (p0.startsWith("//") && !result.startsWith("//")) {
            if (p0.startsWith("//./")) {
              result = "//." + result;
            } else {
              result = "/" + result;
            }
          }
        }
        return result;
      },
      addExt: function(file, ext) {
        if (!ext) {
          return file;
        } else {
          if (ext[0] !== ".") {
            ext = "." + ext;
          }
          return file + (file.endsWith(ext) ? "" : ext);
        }
      },
      trimExt: function(filename, ignoreExts, maxSize) {
        var oldExt;
        if (maxSize == null) {
          maxSize = 7;
        }
        oldExt = upath.extname(filename);
        if (isValidExt(oldExt, ignoreExts, maxSize)) {
          return filename.slice(0, +(filename.length - oldExt.length - 1) + 1 || 9e9);
        } else {
          return filename;
        }
      },
      removeExt: function(filename, ext) {
        if (!ext) {
          return filename;
        } else {
          ext = ext[0] === "." ? ext : "." + ext;
          if (upath.extname(filename) === ext) {
            return upath.trimExt(filename, [], ext.length);
          } else {
            return filename;
          }
        }
      },
      changeExt: function(filename, ext, ignoreExts, maxSize) {
        if (maxSize == null) {
          maxSize = 7;
        }
        return upath.trimExt(filename, ignoreExts, maxSize) + (!ext ? "" : ext[0] === "." ? ext : "." + ext);
      },
      defaultExt: function(filename, ext, ignoreExts, maxSize) {
        var oldExt;
        if (maxSize == null) {
          maxSize = 7;
        }
        oldExt = upath.extname(filename);
        if (isValidExt(oldExt, ignoreExts, maxSize)) {
          return filename;
        } else {
          return upath.addExt(filename, ext);
        }
      }
    };
    isValidExt = function(ext, ignoreExts, maxSize) {
      if (ignoreExts == null) {
        ignoreExts = [];
      }
      return ext && ext.length <= maxSize && indexOf.call(ignoreExts.map(function(e) {
        return (e && e[0] !== "." ? "." : "") + e;
      }), ext) < 0;
    };
    for (name in extraFunctions) {
      if (!hasProp.call(extraFunctions, name))
        continue;
      extraFn = extraFunctions[name];
      if (upath[name] !== void 0) {
        throw new Error("path." + name + " already exists.");
      } else {
        upath[name] = extraFn;
      }
    }
  }
});

// node_modules/@vuetify/loader-shared/dist/index.mjs
var import_node_module = __toESM(require_node_module(), 1);
var import_upath = __toESM(require_upath(), 1);
function parseTemplate(source) {
  const components = createSet(source.matchAll(/(?:var|const) (\w+) = _resolveComponent\("([\w-.]+)"\);?/gm));
  const directives = createSet(source.matchAll(/(?:var|const) (\w+) = _resolveDirective\("([\w-.]+)"\);?/gm));
  return { components, directives };
}
function createSet(matches) {
  return new Set(Array.from(matches, (i) => ({
    symbol: i[1],
    name: capitalize(camelize(i[2])),
    index: i.index,
    length: i[0].length
  })));
}
var require$1 = (0, import_node_module.createRequire)(import.meta.url);
var importMap = require$1("vuetify/dist/json/importMap.json");
var importMapLabs = require$1("vuetify/dist/json/importMap-labs.json");
function getImports(source, options) {
  const { components, directives } = parseTemplate(source);
  const resolvedComponents = [];
  const resolvedDirectives = [];
  const imports = /* @__PURE__ */ new Map();
  const ignore = isObject(options.autoImport) && options.autoImport.ignore || null;
  const includeLabs = isObject(options.autoImport) && options.autoImport.labs;
  const map = includeLabs ? {
    components: { ...importMap.components, ...importMapLabs.components },
    directives: importMap.directives
  } : importMap;
  if (components.size || directives.size) {
    components.forEach((component) => {
      if (ignore == null ? void 0 : ignore.includes(component.name))
        return;
      if (component.name in importMap.components) {
        resolvedComponents.push(component);
      } else if (includeLabs && component.name in importMapLabs.components) {
        resolvedComponents.push(component);
      }
    });
    directives.forEach((directive) => {
      if (importMap.directives.includes(directive.name) && !(ignore == null ? void 0 : ignore.includes(directive.name))) {
        resolvedDirectives.push(directive);
      }
    });
  }
  resolvedComponents.forEach((component) => {
    addImport(imports, component.name, component.symbol, "vuetify/lib/" + map.components[component.name].from);
  });
  resolvedDirectives.forEach((directive) => {
    addImport(imports, directive.name, directive.symbol, "vuetify/lib/directives/index.mjs");
  });
  return {
    imports,
    components: resolvedComponents,
    directives: resolvedDirectives
  };
}
function addImport(imports, name, as, from) {
  if (!imports.has(from)) {
    imports.set(from, []);
  }
  imports.get(from).push(`${name} as ${as}`);
}
function generateImports(source, options) {
  const { imports, components, directives } = getImports(source, options);
  let code = "";
  if (components.length || directives.length) {
    code += "\n\n/* Vuetify */\n";
    Array.from(imports).sort((a, b) => a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0).forEach(([from, names]) => {
      code += `import { ${names.join(", ")} } from "${from}"
`;
    });
    code += "\n";
    source = [...components, ...directives].reduce((acc, v) => {
      return acc.slice(0, v.index) + " ".repeat(v.length) + acc.slice(v.index + v.length);
    }, source);
    if (!source.includes("_resolveComponent(")) {
      source = source.replace("resolveComponent as _resolveComponent, ", "");
    }
    if (!source.includes("_resolveDirective(")) {
      source = source.replace("resolveDirective as _resolveDirective, ", "");
    }
  }
  return { code, source };
}
var require2 = (0, import_node_module.createRequire)(import.meta.url);
function resolveVuetifyBase() {
  return import_upath.default.dirname(require2.resolve("vuetify/package.json", { paths: [process.cwd()] }));
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function includes(arr, val) {
  return arr.includes(val);
}
function normalizePath(p) {
  p = import_upath.default.normalize(p);
  return /^[a-z]:\//i.test(p) ? "/" + p : p;
}
function toKebabCase(str = "") {
  return str.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
}
var defaultTags = {
  video: ["src", "poster"],
  source: ["src"],
  img: ["src"],
  image: ["xlink:href", "href"],
  use: ["xlink:href", "href"]
};
var transformAssetUrls = {
  VAppBar: ["image"],
  VAvatar: ["image"],
  VBanner: ["avatar"],
  VCard: ["image", "prependAvatar", "appendAvatar"],
  VCardItem: ["prependAvatar", "appendAvatar"],
  VCarouselItem: ["src", "lazySrc", "srcset"],
  VChip: ["prependAvatar", "appendAvatar"],
  VImg: ["src", "lazySrc", "srcset"],
  VListItem: ["prependAvatar", "appendAvatar"],
  VNavigationDrawer: ["image"],
  VParallax: ["src", "lazySrc", "srcset"],
  VToolbar: ["image"]
};
for (const [tag, attrs] of Object.entries(transformAssetUrls)) {
  attrs.forEach((attr) => {
    if (/[A-Z]/.test(attr)) {
      attrs.push(toKebabCase(attr));
    }
  });
  transformAssetUrls[toKebabCase(tag)] = attrs;
}
Object.assign(transformAssetUrls, defaultTags);

// node_modules/vite/dist/node/index.js
var import_esbuild = __toESM(require_main());
var import_node_fs = __toESM(require_node_fs());

// node_modules/vite/dist/node/runtime.js
var SOURCEMAPPING_URL = "sourceMa";
SOURCEMAPPING_URL += "ppingURL";
var isWindows = typeof process < "u" && process.platform === "win32";
var AsyncFunction = (async function() {
}).constructor;
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c, charToInt[c] = i;
}
var VITE_RUNTIME_SOURCEMAPPING_REGEXP = new RegExp(
  `//# ${SOURCEMAPPING_URL}=data:application/json;base64,(.+)`
);
var retrieveFileHandlers = /* @__PURE__ */ new Set();
var retrieveSourceMapHandlers = /* @__PURE__ */ new Set();
var createExecHandlers = (handlers) => (...args) => {
  for (const handler of handlers) {
    const result = handler(...args);
    if (result) return result;
  }
  return null;
};
var retrieveFileFromHandlers = createExecHandlers(retrieveFileHandlers);
var retrieveSourceMapFromHandlers = createExecHandlers(
  retrieveSourceMapHandlers
);
var originalPrepare = Error.prepareStackTrace;

// node_modules/vite/dist/node/index.js
var import_promises = __toESM(require_promises());
var import_node_path = __toESM(require_node_path());
var import_node_url = __toESM(require_node_url());
var import_node_util = __toESM(require_node_util());
var import_node_perf_hooks = __toESM(require_node_perf_hooks());
var import_node_module2 = __toESM(require_node_module());
var import_tty = __toESM(require_tty());
var import_path = __toESM(require_path());
var import_fs = __toESM(require_fs());
var import_node_events = __toESM(require_node_events());
var import_node_stream = __toESM(require_node_stream());
var import_node_string_decoder = __toESM(require_node_string_decoder());
var import_node_child_process = __toESM(require_node_child_process());
var import_node_http = __toESM(require_node_http());
var import_node_https = __toESM(require_node_https());
var import_util = __toESM(require_util());
var import_net = __toESM(require_net());
var import_events = __toESM(require_events());
var import_url = __toESM(require_url());
var import_http = __toESM(require_http());
var import_stream = __toESM(require_stream());
var import_os = __toESM(require_os());
var import_child_process = __toESM(require_child_process());
var import_node_os = __toESM(require_node_os());
var import_node_crypto = __toESM(require_node_crypto());
var import_node_dns = __toESM(require_node_dns());
var import_crypto = __toESM(require_crypto());
var import_module = __toESM(require_module());
var import_node_assert = __toESM(require_node_assert());
var import_node_v8 = __toESM(require_node_v8());
var import_node_worker_threads = __toESM(require_node_worker_threads());
var import_node_buffer = __toESM(require_node_buffer());
var import_querystring = __toESM(require_querystring());
var import_node_readline = __toESM(require_node_readline());
var import_zlib = __toESM(require_zlib());
var import_buffer = __toESM(require_buffer());
var import_https = __toESM(require_https());
var import_tls = __toESM(require_tls());
var import_assert = __toESM(require_assert());
var import_node_zlib = __toESM(require_node_zlib());

// node_modules/vite-plugin-vuetify/dist/index.mjs
var import_url2 = __toESM(require_url(), 1);
var import_upath2 = __toESM(require_upath(), 1);
function parseId(id) {
  const [pathname, query] = id.split("?");
  return {
    query: query ? Object.fromEntries(new import_url2.URLSearchParams(query)) : null,
    path: pathname ?? id
  };
}
function importPlugin(options) {
  let filter;
  return {
    name: "vuetify:import",
    configResolved(config) {
      const vuetifyIdx = config.plugins.findIndex((plugin) => plugin.name === "vuetify:import");
      const vueIdx = config.plugins.findIndex((plugin) => plugin.name === "vite:vue");
      if (vuetifyIdx < vueIdx) {
        throw new Error("Vuetify plugin must be loaded after the vue plugin");
      }
      const vueOptions = config.plugins[vueIdx].api.options;
      filter = createFilter(vueOptions.include, vueOptions.exclude);
    },
    async transform(code, id) {
      const { query, path: path3 } = parseId(id);
      const isVueVirtual = query && "vue" in query;
      const isVueFile = !isVueVirtual && filter(path3) && !/^import { render as _sfc_render } from ".*"$/m.test(code);
      const isVueTemplate = isVueVirtual && (query.type === "template" || query.type === "script" && query.setup === "true");
      if (isVueFile || isVueTemplate) {
        const { code: imports, source } = generateImports(code, options);
        return {
          code: source + imports,
          map: null
        };
      }
      return null;
    }
  };
}
function isSubdir(root, test) {
  const relative = import_upath2.default.relative(root, test);
  return relative && !relative.startsWith("..") && !import_upath2.default.isAbsolute(relative);
}
var PLUGIN_VIRTUAL_PREFIX = "virtual:";
var PLUGIN_VIRTUAL_NAME = "plugin-vuetify";
var VIRTUAL_MODULE_ID = `${PLUGIN_VIRTUAL_PREFIX}${PLUGIN_VIRTUAL_NAME}`;
function stylesPlugin(options) {
  const vuetifyBase = resolveVuetifyBase();
  let configFile;
  const tempFiles = /* @__PURE__ */ new Map();
  return {
    name: "vuetify:styles",
    enforce: "pre",
    configResolved(config) {
      if (isObject(options.styles)) {
        if (import_upath2.default.isAbsolute(options.styles.configFile)) {
          configFile = options.styles.configFile;
        } else {
          configFile = import_upath2.default.join(config.root || process.cwd(), options.styles.configFile);
        }
      }
    },
    async resolveId(source, importer, { custom }) {
      if (source === "vuetify/styles" || importer && source.endsWith(".css") && isSubdir(vuetifyBase, import_upath2.default.isAbsolute(source) ? source : importer)) {
        if (options.styles === "none") {
          return `${PLUGIN_VIRTUAL_PREFIX}__void__`;
        } else if (options.styles === "sass") {
          const target = source.replace(/\.css$/, ".sass");
          return this.resolve(target, importer, { skipSelf: true, custom });
        } else if (isObject(options.styles)) {
          const resolution = await this.resolve(source, importer, { skipSelf: true, custom });
          if (!resolution)
            return null;
          const target = resolution.id.replace(/\.css$/, ".sass");
          const file = import_upath2.default.relative(import_upath2.default.join(vuetifyBase, "lib"), target);
          const contents = `@use "${normalizePath(configFile)}"
@use "${normalizePath(target)}"`;
          tempFiles.set(file, contents);
          return `${VIRTUAL_MODULE_ID}:${file}`;
        }
      } else if (source.startsWith(`/${PLUGIN_VIRTUAL_NAME}:`)) {
        return PLUGIN_VIRTUAL_PREFIX + source.slice(1);
      } else if (source.startsWith(`/@id/__x00__${PLUGIN_VIRTUAL_NAME}:`)) {
        return PLUGIN_VIRTUAL_PREFIX + source.slice(12);
      } else if (source.startsWith(`/${VIRTUAL_MODULE_ID}:`)) {
        return source.slice(1);
      }
      return null;
    },
    load(id) {
      if (new RegExp(`^${PLUGIN_VIRTUAL_PREFIX}__void__(\\?.*)?$`).test(id)) {
        return "";
      }
      if (id.startsWith(`${VIRTUAL_MODULE_ID}`)) {
        const file = new RegExp(`^${VIRTUAL_MODULE_ID}:(.*?)(\\?.*)?$`).exec(id)[1];
        return tempFiles.get(file);
      }
      return null;
    }
  };
}
function vuetify(_options = {}) {
  const options = {
    autoImport: true,
    styles: true,
    ..._options
  };
  const plugins = [];
  if (options.autoImport) {
    plugins.push(importPlugin(options));
  }
  if (includes(["none", "sass"], options.styles) || isObject(options.styles)) {
    plugins.push(stylesPlugin(options));
  }
  return plugins;
}
vuetify.transformAssetUrls = transformAssetUrls;
export {
  vuetify as default,
  transformAssetUrls
};
//# sourceMappingURL=vite-plugin-vuetify.js.map
